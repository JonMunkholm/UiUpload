package templates

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/JonMunkholm/TUI/internal/core"
	"github.com/jackc/pgx/v5/pgtype"
)

// ColumnMeta contains metadata about a column for frontend use.
type ColumnMeta struct {
	Name        string   `json:"name"`
	DBColumn    string   `json:"dbColumn"`
	Type        string   `json:"type"` // "text", "numeric", "date", "bool", "enum"
	EnumValues  []string `json:"enumValues,omitempty"`
	IsUniqueKey bool     `json:"isUniqueKey"`
	AllowEmpty  bool     `json:"allowEmpty"`
}

templ TableView(tableKey string, info core.TableInfo, data *core.TableDataResult, columnMeta []ColumnMeta) {
	@Layout(info.Label + " - Data View") {
		<!-- Header with back link -->
		<div class="mb-6">
			<a href="/" class="text-sm text-blue-600 hover:underline mb-2 inline-block">&larr; Back to Dashboard</a>
			<div class="flex items-center justify-between">
				<div>
					<h1 class="text-2xl font-semibold text-gray-900">{ info.Label }</h1>
					<p class="text-sm text-gray-500">
						if data.SearchQuery != "" {
							{ fmt.Sprintf("%d results matching '%s'", data.TotalRows, data.SearchQuery) }
						} else {
							{ fmt.Sprintf("%d total rows", data.TotalRows) }
						}
					</p>
				</div>
				<div class="flex items-center gap-4">
					<!-- Search input -->
					<div class="relative">
						<input
							type="search"
							name="search"
							placeholder="Search..."
							value={ data.SearchQuery }
							class="w-64 pl-10 pr-4 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
							hx-get={ buildSearchURL(tableKey, data) }
							hx-target="#table-container"
							hx-swap="innerHTML"
							hx-push-url="true"
							hx-trigger="keyup changed delay:300ms, search"
							hx-include="this"
						/>
						<svg class="absolute left-3 top-2.5 w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
						</svg>
					</div>
					<!-- Views Dropdown -->
					<div id="views-container" class="relative">
						<button
							type="button"
							onclick="toggleViewsDropdown()"
							class="inline-flex items-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
						>
							<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path>
							</svg>
							Views
						</button>
						<div id="views-dropdown" class="hidden absolute right-0 z-10 mt-2 w-56 bg-white border border-gray-200 rounded-md shadow-lg">
							<!-- Populated by JS -->
						</div>
					</div>
					<!-- Column Toggle Dropdown -->
					<div class="relative">
						<button
							type="button"
							onclick="toggleColumnDropdown()"
							class="inline-flex items-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
						>
							<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2"></path>
							</svg>
							Columns
						</button>
						<div id="column-dropdown" class="hidden absolute right-0 z-10 mt-2 w-56 bg-white border border-gray-200 rounded-md shadow-lg">
							<div class="p-2 border-b border-gray-100 flex gap-2">
								<button type="button" onclick="selectAllColumns()" class="text-xs text-blue-600 hover:underline">All</button>
								<button type="button" onclick="clearAllColumns()" class="text-xs text-blue-600 hover:underline">None</button>
							</div>
							<div id="column-checkboxes" class="max-h-64 overflow-y-auto p-2">
								<!-- Checkboxes rendered by JS -->
							</div>
						</div>
					</div>
					<!-- Export button -->
					if data.TotalRows > 0 {
						<a
							href={ templ.SafeURL(buildExportURL(tableKey, data)) }
							class="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 transition-colors"
						>
							<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
							</svg>
							Export CSV
						</a>
					}
				</div>
			</div>
		</div>

		<!-- Selection Bar (hidden until rows selected) -->
		if len(info.UniqueKey) > 0 {
			<div id="selection-bar" class="hidden mb-4 p-3 bg-red-50 border border-red-200 rounded-lg flex items-center justify-between">
				<span id="selection-count" class="text-sm font-medium text-red-800">0 rows selected</span>
				<button
					type="button"
					onclick="showDeleteModal()"
					class="inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 transition-colors"
				>
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
					</svg>
					Delete Selected
				</button>
			</div>
		}

		<!-- Table container with id for HTMX swaps -->
		<div id="table-container" data-table-key={ tableKey } data-unique-key={ toJSON(info.UniqueKey) } data-columns-meta={ toColumnsMetaJSON(columnMeta) }>
			@TablePartial(tableKey, info, data, columnMeta)
		</div>

		<!-- Delete Confirmation Modal -->
		<div id="delete-modal" class="hidden fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50">
			<div class="bg-white rounded-lg shadow-xl max-w-md w-full mx-4">
				<div class="flex items-center justify-between p-4 border-b">
					<h3 class="text-lg font-semibold text-gray-900">Confirm Delete</h3>
					<button onclick="hideDeleteModal()" class="text-gray-400 hover:text-gray-600">
						<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
						</svg>
					</button>
				</div>
				<div class="p-6">
					<p class="text-gray-700 mb-2">
						Are you sure you want to delete <span id="delete-count" class="font-semibold">0</span> rows?
					</p>
					<p class="text-sm text-red-600">This action cannot be undone.</p>
				</div>
				<div class="flex justify-end gap-3 p-4 border-t bg-gray-50 rounded-b-lg">
					<button
						type="button"
						onclick="hideDeleteModal()"
						class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
					>
						Cancel
					</button>
					<button
						type="button"
						onclick="confirmDelete()"
						class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 transition-colors"
					>
						Delete
					</button>
				</div>
			</div>
		</div>

		<!-- Initialize table features -->
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				initSortPersistence();
				initColumnToggle();
				initViewsDropdown();
				initKeyboardShortcuts();
			});
		</script>
	}
}

templ TablePartial(tableKey string, info core.TableInfo, data *core.TableDataResult, columnMeta []ColumnMeta) {
	<!-- Active Filters Bar -->
	@ActiveFiltersBar(tableKey, data)

	if data.TotalRows == 0 {
		<div class="text-center py-12 bg-white rounded-lg border border-gray-200">
			<svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
				<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
			</svg>
			<h3 class="mt-2 text-sm font-medium text-gray-900">No data yet</h3>
			<p class="mt-1 text-sm text-gray-500">Upload a CSV file to populate this table.</p>
			if len(data.ActiveFilters) > 0 {
				<p class="mt-2 text-sm text-gray-500">Try clearing filters above to see all data.</p>
			}
			<div class="mt-6">
				<a href="/" class="text-sm font-medium text-blue-600 hover:text-blue-500">
					Go to Dashboard to upload &rarr;
				</a>
			</div>
		</div>
	} else {
		<!-- Scrollable table wrapper -->
		<div class="overflow-x-auto border border-gray-200 rounded-lg shadow-sm">
			<table class="min-w-full divide-y divide-gray-200">
				<thead class="bg-gray-50">
					<tr>
						<!-- Checkbox column header (only if table has unique key) -->
						if len(info.UniqueKey) > 0 {
							<th class="px-4 py-3 w-10">
								<input
									type="checkbox"
									id="select-all"
									onclick="toggleSelectAll(this)"
									class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer"
									title="Select all rows on this page"
								/>
							</th>
						}
						for _, col := range info.Columns {
							@SortableHeader(tableKey, col, data, columnMeta)
						}
					</tr>
				</thead>
				<tbody class="bg-white divide-y divide-gray-100">
					for _, row := range data.Rows {
						<tr class="hover:bg-blue-50 transition-colors" data-row-key={ buildRowKey(info.UniqueKey, row) }>
							<!-- Checkbox column (only if table has unique key) -->
							if len(info.UniqueKey) > 0 {
								<td class="px-4 py-2 w-10">
									<input
										type="checkbox"
										class="row-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer"
										data-key={ buildRowKey(info.UniqueKey, row) }
										onclick="updateSelection()"
									/>
								</td>
							}
							for _, col := range info.Columns {
								if len(info.UniqueKey) > 0 {
									<td
										class="px-4 py-2 text-sm text-gray-700 whitespace-nowrap max-w-xs truncate editable-cell cursor-pointer"
										title={ formatCellTitle(row[col]) }
										data-col-name={ col }
										data-raw-value={ formatRawValue(row[col]) }
									>
										{ formatCell(row[col]) }
									</td>
								} else {
									<td class="px-4 py-2 text-sm text-gray-700 whitespace-nowrap max-w-xs truncate" title={ formatCellTitle(row[col]) }>
										{ formatCell(row[col]) }
									</td>
								}
							}
						</tr>
					}
				</tbody>
			</table>
		</div>

		<!-- Pagination -->
		@Pagination(tableKey, data)
	}
}

templ ActiveFiltersBar(tableKey string, data *core.TableDataResult) {
	if len(data.ActiveFilters) > 0 {
		<div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg flex items-center gap-3 flex-wrap">
			<span class="text-sm font-medium text-blue-800">Active filters:</span>
			for col, opVal := range data.ActiveFilters {
				<div class="inline-flex items-center gap-1 px-2 py-1 bg-white border border-blue-300 rounded-full text-sm text-blue-800">
					<span>{ col }: { formatFilterDisplay(opVal) }</span>
					<button
						type="button"
						class="ml-1 text-blue-600 hover:text-blue-800"
						hx-get={ buildClearFilterURL(tableKey, col, data) }
						hx-target="#table-container"
						hx-swap="innerHTML"
						hx-push-url="true"
						title="Remove this filter"
					>
						<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
						</svg>
					</button>
				</div>
			}
			<button
				type="button"
				class="text-sm text-blue-600 hover:text-blue-800 hover:underline"
				hx-get={ buildClearAllFiltersURL(tableKey, data) }
				hx-target="#table-container"
				hx-swap="innerHTML"
				hx-push-url="true"
			>
				Clear all
			</button>
		</div>
	}
}

templ SortableHeader(tableKey, col string, data *core.TableDataResult, columnMeta []ColumnMeta) {
	<th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider select-none relative">
		<div class="flex items-center gap-1">
			<!-- Sortable part -->
			<div
				class="flex items-center gap-1 cursor-pointer hover:text-gray-900"
				hx-get={ buildSortURL(tableKey, col, data) }
				hx-target="#table-container"
				hx-swap="innerHTML"
				hx-push-url="true"
			>
				<span>{ col }</span>
				if data.SortColumn == col {
					if data.SortDir == "asc" {
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
						</svg>
					} else {
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
						</svg>
					}
				}
			</div>

			<!-- Filter icon -->
			<button
				type="button"
				class={ "filter-toggle-btn " + filterIconClass(col, data) }
				data-col={ col }
				title="Filter this column"
			>
				<svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
				</svg>
			</button>

			<!-- Filter dropdown -->
			@FilterDropdown(tableKey, col, data, columnMeta)
		</div>
	</th>
}

// filterIconClass returns CSS classes for the filter icon based on active state.
func filterIconClass(col string, data *core.TableDataResult) string {
	base := "p-1 rounded hover:bg-gray-200 transition-colors"
	if hasFilter(col, data) {
		return base + " text-blue-600"
	}
	return base + " text-gray-400 hover:text-gray-600"
}

// sanitizeForJS escapes a string for use in JavaScript.
func sanitizeForJS(s string) string {
	// Simple escape for single quotes and backslashes
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "'", "\\'")
	return s
}

templ FilterDropdown(tableKey, col string, data *core.TableDataResult, columnMeta []ColumnMeta) {
	<div
		id={ "filter-dropdown-" + sanitizeID(col) }
		class="hidden absolute left-0 top-full mt-1 z-20 bg-white border border-gray-200 rounded-lg shadow-lg p-3 min-w-[200px]"
		onclick="event.stopPropagation()"
	>
		if cm := getColumnMeta(col, columnMeta); cm != nil {
			switch cm.Type {
				case "text":
					@TextFilterControls(tableKey, col, data)
				case "numeric":
					@NumericFilterControls(tableKey, col, data)
				case "date":
					@DateFilterControls(tableKey, col, data)
				case "bool":
					@BoolFilterControls(tableKey, col, data)
				case "enum":
					@EnumFilterControls(tableKey, col, data, cm.EnumValues)
				default:
					@TextFilterControls(tableKey, col, data)
			}
		} else {
			@TextFilterControls(tableKey, col, data)
		}
	</div>
}

// sanitizeID converts a column name to a valid HTML ID.
func sanitizeID(s string) string {
	return strings.ReplaceAll(strings.ToLower(s), " ", "-")
}

templ TextFilterControls(tableKey, col string, data *core.TableDataResult) {
	<div class="space-y-2" data-filter-type="text" data-col={ col } data-table={ tableKey }>
		<label class="block text-xs font-medium text-gray-700">Filter { col }</label>
		<select class="filter-op w-full text-sm border border-gray-300 rounded px-2 py-1">
			<option value="contains">Contains</option>
			<option value="eq">Equals</option>
			<option value="starts">Starts with</option>
			<option value="ends">Ends with</option>
		</select>
		<input
			type="text"
			class="filter-val w-full text-sm border border-gray-300 rounded px-2 py-1"
			placeholder="Filter value..."
		/>
		<div class="flex justify-between pt-2 border-t border-gray-100">
			<button type="button" class="filter-clear-btn text-xs text-gray-600 hover:text-gray-800">
				Clear
			</button>
			<button type="button" class="filter-apply-btn text-xs text-white bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded">
				Apply
			</button>
		</div>
	</div>
}

templ NumericFilterControls(tableKey, col string, data *core.TableDataResult) {
	<div class="space-y-2" data-filter-type="numeric" data-col={ col } data-table={ tableKey }>
		<label class="block text-xs font-medium text-gray-700">Filter { col }</label>
		<div class="grid grid-cols-2 gap-2">
			<div>
				<label class="text-xs text-gray-500">Min</label>
				<input type="number" class="filter-min w-full text-sm border border-gray-300 rounded px-2 py-1" placeholder="Min"/>
			</div>
			<div>
				<label class="text-xs text-gray-500">Max</label>
				<input type="number" class="filter-max w-full text-sm border border-gray-300 rounded px-2 py-1" placeholder="Max"/>
			</div>
		</div>
		<div class="flex justify-between pt-2 border-t border-gray-100">
			<button type="button" class="filter-clear-btn text-xs text-gray-600 hover:text-gray-800">
				Clear
			</button>
			<button type="button" class="filter-apply-btn text-xs text-white bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded">
				Apply
			</button>
		</div>
	</div>
}

templ DateFilterControls(tableKey, col string, data *core.TableDataResult) {
	<div class="space-y-2" data-filter-type="date" data-col={ col } data-table={ tableKey }>
		<label class="block text-xs font-medium text-gray-700">Filter { col }</label>
		<div class="grid grid-cols-2 gap-2">
			<div>
				<label class="text-xs text-gray-500">From</label>
				<input type="date" class="filter-from w-full text-sm border border-gray-300 rounded px-2 py-1"/>
			</div>
			<div>
				<label class="text-xs text-gray-500">To</label>
				<input type="date" class="filter-to w-full text-sm border border-gray-300 rounded px-2 py-1"/>
			</div>
		</div>
		<div class="flex justify-between pt-2 border-t border-gray-100">
			<button type="button" class="filter-clear-btn text-xs text-gray-600 hover:text-gray-800">
				Clear
			</button>
			<button type="button" class="filter-apply-btn text-xs text-white bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded">
				Apply
			</button>
		</div>
	</div>
}

templ BoolFilterControls(tableKey, col string, data *core.TableDataResult) {
	<div class="space-y-2" data-filter-type="bool" data-col={ col } data-table={ tableKey }>
		<label class="block text-xs font-medium text-gray-700">Filter { col }</label>
		<div class="space-y-1">
			<label class="flex items-center gap-2 text-sm">
				<input type="radio" class="filter-bool-radio" name={ "filter-bool-" + sanitizeID(col) } value="" checked/>
				<span>Any</span>
			</label>
			<label class="flex items-center gap-2 text-sm">
				<input type="radio" class="filter-bool-radio" name={ "filter-bool-" + sanitizeID(col) } value="true"/>
				<span>Yes</span>
			</label>
			<label class="flex items-center gap-2 text-sm">
				<input type="radio" class="filter-bool-radio" name={ "filter-bool-" + sanitizeID(col) } value="false"/>
				<span>No</span>
			</label>
		</div>
		<div class="flex justify-between pt-2 border-t border-gray-100">
			<button type="button" class="filter-clear-btn text-xs text-gray-600 hover:text-gray-800">
				Clear
			</button>
			<button type="button" class="filter-apply-btn text-xs text-white bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded">
				Apply
			</button>
		</div>
	</div>
}

templ EnumFilterControls(tableKey, col string, data *core.TableDataResult, enumValues []string) {
	<div class="space-y-2" data-filter-type="enum" data-col={ col } data-table={ tableKey }>
		<label class="block text-xs font-medium text-gray-700">Filter { col }</label>
		<div class="max-h-40 overflow-y-auto space-y-1">
			for _, val := range enumValues {
				<label class="flex items-center gap-2 text-sm">
					<input type="checkbox" class="filter-enum-checkbox" value={ val }/>
					<span>{ val }</span>
				</label>
			}
		</div>
		<div class="flex justify-between pt-2 border-t border-gray-100">
			<button type="button" class="filter-clear-btn text-xs text-gray-600 hover:text-gray-800">
				Clear
			</button>
			<button type="button" class="filter-apply-btn text-xs text-white bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded">
				Apply
			</button>
		</div>
	</div>
}

templ Pagination(tableKey string, data *core.TableDataResult) {
	<div class="flex items-center justify-between px-4 py-3 bg-white border-t border-gray-200 rounded-b-lg">
		<div class="text-sm text-gray-500">
			{ formatRange(data) }
		</div>
		<div class="flex items-center gap-2">
			if data.Page > 1 {
				<button
					class="px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
					hx-get={ buildPageURL(tableKey, data.Page-1, data) }
					hx-target="#table-container"
					hx-swap="innerHTML"
					hx-push-url="true"
				>
					Previous
				</button>
			}

			<!-- Page numbers -->
			for _, p := range pageNumbers(data) {
				if p == data.Page {
					<button
						class="px-3 py-1.5 text-sm font-medium text-white bg-blue-600 border border-blue-600 rounded-md"
						disabled
					>
						{ fmt.Sprintf("%d", p) }
					</button>
				} else if p == -1 {
					<span class="px-2 text-gray-400">...</span>
				} else {
					<button
						class="px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
						hx-get={ buildPageURL(tableKey, p, data) }
						hx-target="#table-container"
						hx-swap="innerHTML"
						hx-push-url="true"
					>
						{ fmt.Sprintf("%d", p) }
					</button>
				}
			}

			if data.Page < data.TotalPages {
				<button
					class="px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
					hx-get={ buildPageURL(tableKey, data.Page+1, data) }
					hx-target="#table-container"
					hx-swap="innerHTML"
					hx-push-url="true"
				>
					Next
				</button>
			}
		</div>
	</div>
}

// Helper functions

// formatCell converts a cell value to a display string.
func formatCell(v interface{}) string {
	if v == nil {
		return "-"
	}

	switch val := v.(type) {
	case pgtype.Numeric:
		if !val.Valid {
			return "-"
		}
		f, err := val.Float64Value()
		if err != nil || !f.Valid {
			return "-"
		}
		return formatNumber(f.Float64)

	case pgtype.Date:
		if !val.Valid {
			return "-"
		}
		return val.Time.Format("2006-01-02")

	case pgtype.Text:
		if !val.Valid {
			return "-"
		}
		return val.String

	case pgtype.Bool:
		if !val.Valid {
			return "-"
		}
		if val.Bool {
			return "Yes"
		}
		return "No"

	case time.Time:
		if val.IsZero() {
			return "-"
		}
		return val.Format("2006-01-02")

	case bool:
		if val {
			return "Yes"
		}
		return "No"

	case string:
		if val == "" {
			return "-"
		}
		return val

	default:
		return fmt.Sprintf("%v", v)
	}
}

// formatCellTitle returns the full value for tooltip.
func formatCellTitle(v interface{}) string {
	if v == nil {
		return ""
	}

	switch val := v.(type) {
	case pgtype.Numeric:
		if !val.Valid {
			return ""
		}
		f, err := val.Float64Value()
		if err != nil || !f.Valid {
			return ""
		}
		return formatNumber(f.Float64)

	case pgtype.Date:
		if !val.Valid {
			return ""
		}
		return val.Time.Format("2006-01-02")

	case pgtype.Text:
		if !val.Valid {
			return ""
		}
		return val.String

	case pgtype.Bool:
		if !val.Valid {
			return ""
		}
		if val.Bool {
			return "Yes"
		}
		return "No"

	case time.Time:
		if val.IsZero() {
			return ""
		}
		return val.Format("2006-01-02")

	case bool:
		if val {
			return "Yes"
		}
		return "No"

	default:
		return fmt.Sprintf("%v", v)
	}
}

// formatNumber formats a float with appropriate precision.
func formatNumber(f float64) string {
	if f == float64(int64(f)) {
		return fmt.Sprintf("%.0f", f)
	}
	return fmt.Sprintf("%.2f", f)
}

// formatRange returns "Showing X-Y of Z" text.
func formatRange(data *core.TableDataResult) string {
	if data.TotalRows == 0 {
		return "No results"
	}
	start := (data.Page-1)*data.PageSize + 1
	end := start + len(data.Rows) - 1
	return fmt.Sprintf("Showing %d-%d of %d", start, end, data.TotalRows)
}

// buildFilterParams builds the query string portion for active filters.
func buildFilterParams(data *core.TableDataResult) string {
	if len(data.ActiveFilters) == 0 {
		return ""
	}
	var parts []string
	for col, opVal := range data.ActiveFilters {
		parts = append(parts, fmt.Sprintf("filter[%s]=%s", url.QueryEscape(col), url.QueryEscape(opVal)))
	}
	return "&" + strings.Join(parts, "&")
}

// buildSortURL builds the URL for sorting by a column.
// Resets to page 1 and preserves search query and filters.
func buildSortURL(tableKey, col string, data *core.TableDataResult) string {
	dir := "asc"
	if data.SortColumn == col && data.SortDir == "asc" {
		dir = "desc"
	}
	base := fmt.Sprintf("/table/%s?page=1&sort=%s&dir=%s", tableKey, col, dir)
	if data.SearchQuery != "" {
		base += "&search=" + url.QueryEscape(data.SearchQuery)
	}
	return base + buildFilterParams(data)
}

// buildPageURL builds the URL for a specific page.
// Preserves sort, search, and filters.
func buildPageURL(tableKey string, page int, data *core.TableDataResult) string {
	base := fmt.Sprintf("/table/%s?page=%d&sort=%s&dir=%s", tableKey, page, data.SortColumn, data.SortDir)
	if data.SearchQuery != "" {
		base += "&search=" + url.QueryEscape(data.SearchQuery)
	}
	return base + buildFilterParams(data)
}

// buildSearchURL builds the base URL for search submissions.
// Resets to page 1 and preserves sort and filters.
func buildSearchURL(tableKey string, data *core.TableDataResult) string {
	base := fmt.Sprintf("/table/%s?page=1&sort=%s&dir=%s", tableKey, data.SortColumn, data.SortDir)
	return base + buildFilterParams(data)
}

// buildExportURL builds the URL for CSV export.
// Includes search and filters if active.
func buildExportURL(tableKey string, data *core.TableDataResult) string {
	base := "/api/export/" + tableKey
	var params []string
	if data.SearchQuery != "" {
		params = append(params, "search="+url.QueryEscape(data.SearchQuery))
	}
	for col, opVal := range data.ActiveFilters {
		params = append(params, fmt.Sprintf("filter[%s]=%s", url.QueryEscape(col), url.QueryEscape(opVal)))
	}
	if len(params) > 0 {
		return base + "?" + strings.Join(params, "&")
	}
	return base
}

// buildClearFilterURL builds the URL with a specific filter removed.
func buildClearFilterURL(tableKey, colToClear string, data *core.TableDataResult) string {
	base := fmt.Sprintf("/table/%s?page=1&sort=%s&dir=%s", tableKey, data.SortColumn, data.SortDir)
	if data.SearchQuery != "" {
		base += "&search=" + url.QueryEscape(data.SearchQuery)
	}
	// Add all filters except the one being cleared
	for col, opVal := range data.ActiveFilters {
		if col != colToClear {
			base += fmt.Sprintf("&filter[%s]=%s", url.QueryEscape(col), url.QueryEscape(opVal))
		}
	}
	return base
}

// buildClearAllFiltersURL builds the URL with all filters removed.
func buildClearAllFiltersURL(tableKey string, data *core.TableDataResult) string {
	base := fmt.Sprintf("/table/%s?page=1&sort=%s&dir=%s", tableKey, data.SortColumn, data.SortDir)
	if data.SearchQuery != "" {
		base += "&search=" + url.QueryEscape(data.SearchQuery)
	}
	return base
}

// pageNumbers returns the page numbers to display in pagination.
func pageNumbers(data *core.TableDataResult) []int {
	if data.TotalPages <= 7 {
		// Show all pages
		pages := make([]int, data.TotalPages)
		for i := range pages {
			pages[i] = i + 1
		}
		return pages
	}

	// Show first, last, current, and neighbors with ellipsis
	pages := []int{1}

	if data.Page > 3 {
		pages = append(pages, -1) // ellipsis
	}

	for p := data.Page - 1; p <= data.Page+1; p++ {
		if p > 1 && p < data.TotalPages {
			pages = append(pages, p)
		}
	}

	if data.Page < data.TotalPages-2 {
		pages = append(pages, -1) // ellipsis
	}

	pages = append(pages, data.TotalPages)

	return pages
}

// buildRowKey builds the unique key value for a row.
// Joins multiple key column values with "|" separator.
func buildRowKey(uniqueKey []string, row core.TableRow) string {
	if len(uniqueKey) == 0 {
		return ""
	}

	parts := make([]string, len(uniqueKey))
	for i, col := range uniqueKey {
		val := row[col]
		parts[i] = formatCellForKey(val)
	}
	return strings.Join(parts, "|")
}

// formatCellForKey formats a cell value as a string key.
func formatCellForKey(v interface{}) string {
	if v == nil {
		return ""
	}

	switch val := v.(type) {
	case pgtype.Text:
		if !val.Valid {
			return ""
		}
		return val.String
	case pgtype.Numeric:
		if !val.Valid {
			return ""
		}
		f, err := val.Float64Value()
		if err != nil || !f.Valid {
			return ""
		}
		if f.Float64 == float64(int64(f.Float64)) {
			return fmt.Sprintf("%.0f", f.Float64)
		}
		return fmt.Sprintf("%v", f.Float64)
	case string:
		return val
	default:
		return fmt.Sprintf("%v", v)
	}
}

// formatRawValue formats a cell value as a raw string for editing.
// Dates are formatted as YYYY-MM-DD, bools as "true"/"false".
func formatRawValue(v interface{}) string {
	if v == nil {
		return ""
	}

	switch val := v.(type) {
	case pgtype.Text:
		if !val.Valid {
			return ""
		}
		return val.String

	case pgtype.Numeric:
		if !val.Valid {
			return ""
		}
		f, err := val.Float64Value()
		if err != nil || !f.Valid {
			return ""
		}
		if f.Float64 == float64(int64(f.Float64)) {
			return fmt.Sprintf("%.0f", f.Float64)
		}
		return fmt.Sprintf("%v", f.Float64)

	case pgtype.Date:
		if !val.Valid {
			return ""
		}
		return val.Time.Format("2006-01-02")

	case pgtype.Bool:
		if !val.Valid {
			return ""
		}
		if val.Bool {
			return "true"
		}
		return "false"

	case time.Time:
		if val.IsZero() {
			return ""
		}
		return val.Format("2006-01-02")

	case bool:
		if val {
			return "true"
		}
		return "false"

	case string:
		return val

	default:
		return fmt.Sprintf("%v", v)
	}
}

// toColumnsMetaJSON serializes column metadata to JSON for the data attribute.
func toColumnsMetaJSON(meta []ColumnMeta) string {
	if len(meta) == 0 {
		return "[]"
	}
	data, err := json.Marshal(meta)
	if err != nil {
		return "[]"
	}
	return string(data)
}

// formatFilterDisplay formats an "op:value" string for user display.
func formatFilterDisplay(opVal string) string {
	parts := strings.SplitN(opVal, ":", 2)
	if len(parts) != 2 {
		return opVal
	}
	op, val := parts[0], parts[1]

	opLabels := map[string]string{
		"contains": "contains",
		"eq":       "=",
		"starts":   "starts with",
		"ends":     "ends with",
		"gte":      "≥",
		"lte":      "≤",
		"gt":       ">",
		"lt":       "<",
		"in":       "in",
	}

	label, ok := opLabels[op]
	if !ok {
		label = op
	}

	return label + " " + val
}

// hasFilter checks if a column has an active filter.
func hasFilter(col string, data *core.TableDataResult) bool {
	_, ok := data.ActiveFilters[col]
	return ok
}

// getColumnMeta returns the ColumnMeta for a given column name.
func getColumnMeta(col string, meta []ColumnMeta) *ColumnMeta {
	for i := range meta {
		if meta[i].Name == col {
			return &meta[i]
		}
	}
	return nil
}
