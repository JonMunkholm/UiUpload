// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit_log.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveOldAuditLogs = `-- name: ArchiveOldAuditLogs :one
SELECT archive_audit_log($1::INTEGER, $2::INTEGER) AS archived_count
`

type ArchiveOldAuditLogsParams struct {
	Column1 int32 `json:"column_1"`
	Column2 int32 `json:"column_2"`
}

func (q *Queries) ArchiveOldAuditLogs(ctx context.Context, arg ArchiveOldAuditLogsParams) (int32, error) {
	row := q.db.QueryRow(ctx, archiveOldAuditLogs, arg.Column1, arg.Column2)
	var archived_count int32
	err := row.Scan(&archived_count)
	return archived_count, err
}

const getAuditLogArchiveAll = `-- name: GetAuditLogArchiveAll :many
SELECT id, action, severity, table_key, user_id, user_email, user_name, ip_address, user_agent, row_key, column_name, old_value, new_value, row_data, rows_affected, upload_id, batch_id, related_audit_id, reason, created_at, archived_at FROM audit_log_archive
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditLogArchiveAllParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetAuditLogArchiveAll(ctx context.Context, arg GetAuditLogArchiveAllParams) ([]AuditLogArchive, error) {
	rows, err := q.db.Query(ctx, getAuditLogArchiveAll,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLogArchive{}
	for rows.Next() {
		var i AuditLogArchive
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Severity,
			&i.TableKey,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.IpAddress,
			&i.UserAgent,
			&i.RowKey,
			&i.ColumnName,
			&i.OldValue,
			&i.NewValue,
			&i.RowData,
			&i.RowsAffected,
			&i.UploadID,
			&i.BatchID,
			&i.RelatedAuditID,
			&i.Reason,
			&i.CreatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogArchiveByTable = `-- name: GetAuditLogArchiveByTable :many
SELECT id, action, severity, table_key, user_id, user_email, user_name, ip_address, user_agent, row_key, column_name, old_value, new_value, row_data, rows_affected, upload_id, batch_id, related_audit_id, reason, created_at, archived_at FROM audit_log_archive
WHERE table_key = $1 AND created_at >= $2 AND created_at <= $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetAuditLogArchiveByTableParams struct {
	TableKey    string             `json:"table_key"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetAuditLogArchiveByTable(ctx context.Context, arg GetAuditLogArchiveByTableParams) ([]AuditLogArchive, error) {
	rows, err := q.db.Query(ctx, getAuditLogArchiveByTable,
		arg.TableKey,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLogArchive{}
	for rows.Next() {
		var i AuditLogArchive
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Severity,
			&i.TableKey,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.IpAddress,
			&i.UserAgent,
			&i.RowKey,
			&i.ColumnName,
			&i.OldValue,
			&i.NewValue,
			&i.RowData,
			&i.RowsAffected,
			&i.UploadID,
			&i.BatchID,
			&i.RelatedAuditID,
			&i.Reason,
			&i.CreatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, action, severity, table_key, user_id, user_email, user_name, ip_address, user_agent, row_key, column_name, old_value, new_value, row_data, rows_affected, upload_id, batch_id, related_audit_id, reason, created_at FROM audit_log WHERE id = $1
`

func (q *Queries) GetAuditLogByID(ctx context.Context, id pgtype.UUID) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.Severity,
		&i.TableKey,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.IpAddress,
		&i.UserAgent,
		&i.RowKey,
		&i.ColumnName,
		&i.OldValue,
		&i.NewValue,
		&i.RowData,
		&i.RowsAffected,
		&i.UploadID,
		&i.BatchID,
		&i.RelatedAuditID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const insertAuditLog = `-- name: InsertAuditLog :one
INSERT INTO audit_log (
    action, severity, table_key,
    user_id, user_email, user_name,
    ip_address, user_agent,
    row_key, column_name,
    old_value, new_value, row_data, rows_affected,
    upload_id, batch_id, related_audit_id, reason
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8,
    $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18
) RETURNING id, action, severity, table_key, user_id, user_email, user_name, ip_address, user_agent, row_key, column_name, old_value, new_value, row_data, rows_affected, upload_id, batch_id, related_audit_id, reason, created_at
`

type InsertAuditLogParams struct {
	Action         string      `json:"action"`
	Severity       string      `json:"severity"`
	TableKey       string      `json:"table_key"`
	UserID         pgtype.Text `json:"user_id"`
	UserEmail      pgtype.Text `json:"user_email"`
	UserName       pgtype.Text `json:"user_name"`
	IpAddress      *netip.Addr `json:"ip_address"`
	UserAgent      pgtype.Text `json:"user_agent"`
	RowKey         pgtype.Text `json:"row_key"`
	ColumnName     pgtype.Text `json:"column_name"`
	OldValue       pgtype.Text `json:"old_value"`
	NewValue       pgtype.Text `json:"new_value"`
	RowData        []byte      `json:"row_data"`
	RowsAffected   pgtype.Int4 `json:"rows_affected"`
	UploadID       pgtype.UUID `json:"upload_id"`
	BatchID        pgtype.UUID `json:"batch_id"`
	RelatedAuditID pgtype.UUID `json:"related_audit_id"`
	Reason         pgtype.Text `json:"reason"`
}

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, insertAuditLog,
		arg.Action,
		arg.Severity,
		arg.TableKey,
		arg.UserID,
		arg.UserEmail,
		arg.UserName,
		arg.IpAddress,
		arg.UserAgent,
		arg.RowKey,
		arg.ColumnName,
		arg.OldValue,
		arg.NewValue,
		arg.RowData,
		arg.RowsAffected,
		arg.UploadID,
		arg.BatchID,
		arg.RelatedAuditID,
		arg.Reason,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.Severity,
		&i.TableKey,
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.IpAddress,
		&i.UserAgent,
		&i.RowKey,
		&i.ColumnName,
		&i.OldValue,
		&i.NewValue,
		&i.RowData,
		&i.RowsAffected,
		&i.UploadID,
		&i.BatchID,
		&i.RelatedAuditID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const purgeOldArchives = `-- name: PurgeOldArchives :one
SELECT purge_old_archives($1::INTEGER) AS deleted_count
`

func (q *Queries) PurgeOldArchives(ctx context.Context, dollar_1 int32) (int32, error) {
	row := q.db.QueryRow(ctx, purgeOldArchives, dollar_1)
	var deleted_count int32
	err := row.Scan(&deleted_count)
	return deleted_count, err
}
